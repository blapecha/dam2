{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang3082{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang10\par
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\par
\fs32 2. Desarrolla aplicaciones que gestionan informaci\'f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\'f3n.\fs22\par
\par
\par
\b a) Se han valorado las ventajas e inconvenientes de utilizar conectores.\b0\par
\par
Explica las ventajas que has visto que ha tenido el desarrollo de una clase (POO) para gestionar las conexiones de la base de datos\par
\par
Las aplicaciones que gestionan bases de datos relacionales suelen requerir mecanismos de conexi\'f3n que permitan interactuar con el motor de base de datos (MySQL, PostgreSQL, SQL Server, Oracle, etc.). Este proceso implica establecer una conexi\'f3n para realizar operaciones como insertar, consultar, actualizar y eliminar datos.\par
Una parte esencial de este desarrollo es elegir y usar conectores de base de datos, que act\'faan como un puente entre el lenguaje de programaci\'f3n y el sistema de gesti\'f3n de bases de datos (SGBD).\par
VENTAJAS DE USAR CONECTORES EN BBDD\par
Interoperabilidad. Las aplicaciones escritas en diferentes lenguajes pueden interact\'faar con los sistemas de gesti\'f3n de las bases de datos. \par
Abstracci\'f3n . Ocultan detalles t\'e9cnicos del protocolo de comunicaci\'f3n. Hacen c\'f3digo limpio y f\'e1cil. \par
Compatibilidad Multiplataforma. Permiten trabajar con m\'faltiples SGBD. Con cambios m\'ednimos de c\'f3digo. \par
Seguridad . Evitan vulnerabilidades gracias al uso de par\'e1metros y consultas seguras. \par
Gesti\'f3n de Transacciones. Permiten confirmar y hacer cambios en bloques. \par
Rendimiento , los conectores reutilizan los recursos y pueden soportar conexiones persistentes. \par
Soporte y estabilidad . Son desarrollados y mantenidos por comunidades o empresas que garantizan su actualizaci\'f3n. \par
\par
INCONVENIENTES DE USAR CONECTORES EN BBDD\par
Dependencia de Librer\'edas. La aplicaci\'f3n depende de que el conector este instalado y configurado en el entorno donde se ejecute. \par
Curva de aprendizaje. Cada conector tiene su API y sintaxis  requerira tiempo saber como usarla de forma correcta. \par
Compatibilidad limitada.  Algunos conectores est\'e1n dise\'f1ados para un solo tipo de SGBD lo que dificulta la portabilidad . \par
Sobrecarga de Abstracci\'f3n . Puede limitar el acceso a funciones avanzadas . \par
Impacto en el Rendimiento , implica una peque\'f1a sobrecarga en el procesamiento. \par
Configuraci\'f3n compleja\par
\par
\par
\b b) Se han utilizado gestores de bases de datos embebidos e independientes.\b0\par
\par
Explica que hemos utilizado MySQL y que de momento toda la logica de la clase est\'e1 en funci\'f3n de MySQL.\par
De momento la base de datos siempre esta en marcha y es independiente del programa . Unicamente se utiliza para guardar informaci\'f3n de la aplicaci\'f3n. \par
\par
\b c) Se ha utilizado el conector id\'f3neo en la aplicaci\'f3n.\b0\par
\par
Hemos utilizado MySQLi para las conexiones.\par
Si el conector adecuado para la base de datos , mas que nada porque con otros no me puedo conectar. \par
\par
\b d) Se ha establecido la conexi\'f3n.\b0\par
\par
En la version 27 . metodos para proximos dias . En establecimiento de conexiones. \par
Al inicializar el objeto conexionDB  se ponen valores a sus propiedades y en el propiedad conexi\'f3n guardamos la conexi\'f3n inicializada. \par
Esta clase tiene una serie de metodos que realizan acciones con la base de datos . Utilizando la propiedad conexi\'f3n que hemos inicializado previamente. \par
\par
\par
\b e) Se ha definido la estructura de la base de datos.\b0\par
\par
Indica tanto los m\'e9todos como el enrutador, y la forma en la que hemos convertir el enrutador en un proveedor de microservicios\par
\par
\par
\b f) Se han desarrollado aplicaciones que modifican el contenido de la base de datos.\b0\par
\par
Explica tanto los m\'e9todos de seleccion, insercion, eliminacion, actualizacion, etc\par
En el fichero 27 la clase que hemos implementado el metodo en el que seleccionamos las tablas .\par
He modificado el c\'f3digo para que acepte un parametro por la url para que el metodo seleccionatabla funcione con ese valor. \par
El resto de metodos aunque no los hemos implementado todavia , no estan desarrollados en esta unidad pero si los hemos visto en la asignatura de bases de datos .\par
SELECT , INSERT, DELETE y UPDATE. \par
\par
\par
\b g) Se han definido los objetos destinados a almacenar el resultado de las consultas.\b0\par
\par
En bases de datos, cuando realizamos consultas y obtenemos resultados, es com\'fan almacenar estos resultados en objetos estructurados. En el contexto de programaci\'f3n y bases de datos, JSON (JavaScript Object Notation) es un formato muy utilizado para representar estos objetos debido a su simplicidad y legibilidad.\par
\par
\b h) Se han desarrollado aplicaciones que efect\'faan consultas.\b0\par
\par
Explica la integraci\'f3n que ha habido entre el proyecto de acceso a datos y el proyecto de sistemas de gesti\'f3n empresarial. En ambas si la consulta de mostrar las tablas . Show tables.\par
\par
\cf1 i) Se han eliminado los objetos una vez finalizada su funci\'f3n.\par
\par
j) Se han gestionado las transacciones.\par
\cf0\par
\b k) Se han ejecutado procedimientos almacenados en la base de datos.\b0\par
\par
Explica los procedimientos almacenados que hemos realizado en la base de datos y los procedimientos con par\'e1metros.\par
Los procesos almacenados son herramientas muy poderosas para realizar operaciones complejas y repetitivas en bases de datos de manera eficiente. Ayudan a encapsular la l\'f3gica de negocio en la base de datos, mejorando el rendimiento y la seguridad, y permitiendo un mantenimiento m\'e1s organizado de la base de datos. Sin embargo, tambi\'e9n deben usarse con precauci\'f3n, ya que pueden hacer que el sistema se vuelva menos flexible si no se gestionan adecuadamente.\par
El c\'f3digo la Carpeta 7 Ejecuci\'f3n ... hace un procedimiento almacenado de la siguiente forma \par
El script se conecta a una base de datos MySQL.\par
Llama a un procedimiento almacenado que realiza una consulta (CALL SeleccionaClientesMalo();).\par
Itera sobre los resultados devueltos y los imprime en pantalla.\par
Este enfoque es \'fatil para encapsular l\'f3gica SQL compleja en el servidor de base de datos y reutilizarla en aplicaciones PHP.\par
\par
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\par
\b\par
\b0\fs32 3. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan.\b\fs22\par
\b0\par
Criterios de evaluaci\'f3n:\par
\par
\b a) Se ha instalado la herramienta ORM.\b0\par
\par
En nuestro caso no hemos instalado herramientas de mapeado objetos relacional sino que hemos desarrollado herramientas propias para realizar este mapeado .\par
La herramienta utiliza la informaci\'f3n de las clases para crear tablas en funcion de su nombre y columnas en funcion de las propiedades de las clases. Con un c\'f3digo generico tenemos la capacidad de crear cualquier tabla con sus columnas en funci\'f3n de la clase con la que queramos trabajar. \par
A partir de esta definici\'f3n nuestro c\'f3digo trabajara creando la tabla correspondiente a esta clase. \par
class Profesor:\par
    def __init__(self,\par
                    nuevonombre,\par
                    nuevadescripcion,\par
                     nuevosalumnos):\par
        self.nombre = nuevonombre\par
        self.descripcion = nuevadescripcion\par
        self.alumnos =  nuevosalumnos\par
clase = "Profesor"\par
\par
Lo primero que hace es comprobar si la tabla existe y la borra en el caso de que as\'ed sea. \par
\par
peticion = "DROP TABLE IF EXISTS "+clase\par
cursor.execute(peticion)\par
\par
Construyo la sql para crear la tabla con sus atributos a partir de la informaci\'f3n de la clase. \par
Esto permite que sea independiente del n\'famero de atributos. \par
En el caso de que uno de los atributos sea un array  crea una tabla independiente para guardar la informaci\'f3n del array con un registro por posici\'f3n asociandolo a la clave primaria de la tabla padre. \par
\par
peticion = "CREATE TABLE IF NOT EXISTS "+clase+" (Identificador INT NOT NULL AUTO_INCREMENT,"                                       # Preparo el principio de la petici\'f3n\par
\par
atributos = [attr for attr in dir(profesores[0]) if not callable(getattr(profesores[0], attr)) and not attr.startswith("__")]   # Listo los atributos de la clase\par
\par
for atributo in atributos:                                                              # Para cada uno de los atributos\par
    if not isinstance(getattr(profesores[0], atributo), list):\par
        peticion += atributo+" VARCHAR(255) NOT NULL ,"                                     # Los encadeno a la peticion\par
    else:\par
        peticion2 = "DROP TABLE IF EXISTS "+atributo+""\par
        cursor.execute(peticion2)\par
        peticion2 = "CREATE TABLE IF NOT EXISTS "+atributo+" (Identificador INT NOT NULL AUTO_INCREMENT,FK INT(255),"+atributo+" VARCHAR(255),PRIMARY KEY (Identificador))"\par
        cursor.execute(peticion2)\par
\par
\par
peticion += " PRIMARY KEY (Identificador))"                                                                         # Cierro el parentesis de la peticion\par
\par
print(peticion)\par
cursor.execute(peticion)  \par
\par
\b b) Se ha configurado la herramienta ORM.\b0\par
 007 ponemos a prueba el modelo parte 1. \par
Cuando recorremos los atributos de la clase en funci\'f3n de si el atributo contiene un array creamos una tabla a proposito para guardar la informacion de ese array . En caso contrario creamos una columna de tipo varchar con el nombre de ese atributo. \par
\par
for atributo in atributos:                                                              # Para cada uno de los atributos\par
    if not isinstance(getattr(profesores[0], atributo), list):\par
        peticion += atributo+" VARCHAR(255) NOT NULL ,"                                     # Los encadeno a la peticion\par
    else:\par
        peticion2 = "DROP TABLE IF EXISTS "+atributo+""\par
        cursor.execute(peticion2)\par
        peticion2 = "CREATE TABLE IF NOT EXISTS "+atributo+" (Identificador INT NOT NULL AUTO_INCREMENT,FK INT(255),"+atributo+" VARCHAR(255),PRIMARY KEY (Identificador))"\par
        cursor.execute(peticion2)\par
\par
Cuando generamos el insert para insertar datos comprobamos si el atributo es un array y en ese caso insertamos los datos en la tabla anteriormente creada. \par
\par
 for atributo in atributos:                                                          # Para cada uno de los atributos\par
        if not isinstance(getattr(profesor, atributo), list):\par
            peticion += "'"+str(getattr(profesor, atributo))+"',"                            # Encadeno ese atributo a la peticion de insert\par
        else:\par
            for elemento in getattr(profesor, atributo):\par
                peticion2 = "INSERT INTO "+atributo+" VALUES(NULL,"+str(indice+1)+",'"+str(elemento)+"')"\par
                cursor.execute(peticion2) \par
\par
En la 7 hemos creado las querys para crear las tablas e insertar datos y en la 8 hemos creado las querys para recuperar datos y guardarlos en las clases. \par
\par
\b c) Se han definido configuraciones de mapeo.\b0\par
Si como he comentado anteriormente , el orm se basa en la construcci\'f3n de querys sql que se ejecutaran en la base de datos . Estas querys se construyen en funci\'f3n de las propiedades que tienen las clases. \par
Por un lado extraemos la informaci\'f3n de la clase para crear las tablas con las columnas correspondientes y en el caso de un array creamos otra tabla en la que en su campo FK referenciaremos el identificador de la tabla padre. Por otro lado construiremos los sql para realizar la inserci\'f3n con los valores de las clases. \par
\par
\b d) Se han aplicado mecanismos de persistencia a los objetos.\b0\par
Este ORM  funciona con mysql porque consiste en la creaci\'f3n de querys para crear las tablas y las querys para insertar datos. Nos conectamos a la base de datos con el conector de mysql y construimos las querys dinamicamente. \par
\par
\b e) Se han desarrollado aplicaciones que modifican y recuperan objetos persistentes.\b0\par
En el 8 ponemos a rpueba el modelo 2 . \par
Lanzamos un query a la base de datos a la tabla que contiene la informaci\'f3n de nuestra clase. Por cada una de las filas que nos devuelve , creamos un nuevo profesor y por cada columna que hay en esa fila , guardamos los datos en la propiedad correspondiente. \par
En el caso de que valor sea igual a none guardamos un array vacio y lanzamos otra consulta a la tabla en la que se han guardado los valores de esa propiedad.\par
\par
\par
\cf1 f) Se han desarrollado aplicaciones que realizan consultas usando el lenguaje SQL.\par
\par
g) Se han gestionado las transacciones.\par
\cf0 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\par
}
 